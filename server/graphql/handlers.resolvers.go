package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"os"
	"stormlink/server/ent"
	"stormlink/server/ent/bookmark"
	"stormlink/server/ent/commentlike"
	"stormlink/server/ent/community"
	"stormlink/server/ent/communityfollow"
	"stormlink/server/ent/communityuserban"
	"stormlink/server/ent/communityusermute"
	"stormlink/server/ent/post"
	"stormlink/server/ent/postlike"
	"stormlink/server/ent/profiletableinfoitem"
	"stormlink/server/ent/role"
	"stormlink/server/ent/user"
	"stormlink/server/ent/userfollow"
	"stormlink/server/graphql/models"
	authpb "stormlink/server/grpc/auth/protobuf"
	mailpb "stormlink/server/grpc/mail/protobuf"
	mediapb "stormlink/server/grpc/media/protobuf"
	userpb "stormlink/server/grpc/user/protobuf"
	"stormlink/server/model"
	"stormlink/server/model/converter"
	"stormlink/shared/auth"
	httpWithCookies "stormlink/shared/http"
	sharedmapper "stormlink/shared/mapper"
	redisx "stormlink/shared/redis"
	"strconv"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gosimple/slug"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
)

// CommentStatus is the resolver for the commentStatus field.
func (r *commentResolver) CommentStatus(ctx context.Context, obj *ent.Comment) (*models.CommentStatus, error) {
	// Берём текущего пользователя из контекста, для корректного isLiked
	uid := 0
	if id, err := auth.UserIDFromContext(ctx); err == nil {
		uid = id
	}
	return r.CommentUC.GetCommentStatus(ctx, uid, obj.ID)
}

// ViewerPermissions для запроса сообществ.
func (r *communityResolver) ViewerPermissions(ctx context.Context, obj *ent.Community) (*model.CommunityPermissions, error) {
	// 1) Пытаемся достать userID из контекста
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		// аноним — никаких прав
		return &model.CommunityPermissions{}, nil
	}

	communityID := obj.ID

	// 2) Спрашиваем именно по одному сообществу
	permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, userID, []int{communityID})
	if err != nil {
		return nil, fmt.Errorf("failed loading perms: %w", err)
	}
	base := permsMap[communityID]
	if base == nil {
		base = &model.CommunityPermissions{}
	}
	cm := converter.ConvertPermissionsToCommunityPermissions(base)

	// 3) Если юзер — владелец сообщества, даём ему полный набор community-прав
	communityEntity, err := r.Client.Community.Get(ctx, communityID)
	if err == nil && communityEntity.OwnerID == userID {
		cm.CommunityOwner = true
		cm.CommunityRolesManagement = true
		cm.CommunityUserBan = true
		cm.CommunityUserMute = true
		cm.CommunityDeletePost = true
		cm.CommunityDeleteComments = true
		cm.CommunityRemovePostFromPublication = true
	}

	// 4) Если юзер — владелец платформы
	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err == nil && hostEntity.OwnerID != nil && *hostEntity.OwnerID == userID {
		cm.HostOwner = true
	}

	return cm, nil
}

// CommunityStatus возвращает статус сообщества для текущего пользователя.
func (r *communityResolver) CommunityStatus(ctx context.Context, obj *ent.Community) (*models.CommunityStatus, error) {
	// 1) Получаем userID из контекста (анонимы получат пустой статус)
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		// аноним — просто вернём нулевой объект
		return &models.CommunityStatus{
			FollowersCount: "0",
			PostsCount:     "0",
			IsFollowing:    false,
			IsBanned:       false,
			IsMuted:        false,
		}, nil
	}

	// 2) Вызываем usecase для одного сообщества
	status, err := r.CommunityUC.GetCommunityStatus(ctx, userID, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("CommunityStatus usecase: %w", err)
	}

	return status, nil
}

// Мутация Host для настроек платформы.
func (r *mutationResolver) Host(ctx context.Context, input models.UpdateHostInput) (*ent.Host, error) {
	upd := r.Client.Host.UpdateOneID(1)
	// каждый Set* вызываем только если в input поле не nil
	if input.Title != nil {
		upd = upd.SetTitle(*input.Title)
	}
	if input.Slogan != nil {
		upd = upd.SetSlogan(*input.Slogan)
	}
	if input.Contacts != nil {
		upd = upd.SetContacts(*input.Contacts)
	}
	if input.Description != nil {
		upd = upd.SetDescription(*input.Description)
	}
	if input.FirstSettings != nil {
		upd = upd.SetFirstSettings(*input.FirstSettings)
	}
	return upd.Save(ctx)
}

// Мутация Post для редактирования поста
func (r *mutationResolver) Post(ctx context.Context, input models.UpdatePostInput) (*ent.Post, error) {
	id, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID %q: %w", input.ID, err)
	}
	upd := r.Client.Post.
		UpdateOneID(id)
	if input.Title != nil {
		upd = upd.SetTitle(*input.Title)
	}
	if input.Slug != nil {
		upd = upd.SetSlug(*input.Slug)
	}
	if input.Content != nil {
		upd = upd.SetContent(input.Content)
	}
	if input.HeroImageID != nil {
		heroID, err := strconv.Atoi(*input.HeroImageID)
		if err != nil {
			return nil, fmt.Errorf("invalid heroImageID %q: %w", *input.HeroImageID, err)
		}
		upd = upd.SetHeroImageID(heroID)
	}
	if input.Visibility != nil {
		upd = upd.SetVisibility(*input.Visibility)
	}
	if input.PublishedAt != nil {
		upd = upd.SetPublishedAt(*input.PublishedAt)
	}
	return upd.Save(ctx)
}

// CreatePost создает новый пост и генерирует slug.
func (r *mutationResolver) CreatePost(ctx context.Context, input models.CreatePostInput) (*ent.Post, error) {
	baseSlug := slug.Make(input.Title)
	suffix := rand.Intn(90_000_000) + 10_000_000
	finalSlug := fmt.Sprintf("%s-%d", baseSlug, suffix)

	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	authorID, err := strconv.Atoi(input.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("invalid authorID: %w", err)
	}
	builder := r.Client.Post.
		Create().
		SetTitle(input.Title).
		SetSlug(finalSlug).
		SetContent(input.Content).
		SetAuthorID(authorID).
		SetCommunityID(communityID)

	if input.HeroImageID != nil {
		if mediaID, err := strconv.Atoi(*input.HeroImageID); err == nil {
			builder = builder.SetHeroImageID(mediaID)
		}
	}

	// Устанавливаем visibility
	if input.Visibility != nil {
		builder = builder.SetVisibility(*input.Visibility)
	}

	if input.PublishedAt != nil {
		builder = builder.SetPublishedAt(time.Time(*input.PublishedAt))
	}

	newPost, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create post: %w", err)
	}
	return newPost, nil
}

// CreateCommunity создает новое сообщество.
func (r *mutationResolver) CreateCommunity(ctx context.Context, input models.CreateCommunityInput) (*ent.Community, error) {
	exists, err := r.Client.Community.
		Query().
		Where(community.SlugEQ(input.Slug)).
		Exist(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing slug: %w", err)
	}
	if exists {
		return nil, gqlerror.Errorf("Community with slug %q already exists", input.Slug)
	}

	// Создаем сообщество
	newComm, err := r.Client.Community.
		Create().
		SetTitle(input.Title).
		SetSlug(input.Slug).
		SetNillableDescription(input.Description).
		SetOwnerID(func() int {
			id, _ := strconv.Atoi(input.OwnerID)
			return id
		}()).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create community: %w", err)
	}

	// Создаем роль "@everyone" для нового сообщества
	everyoneRole, err := r.Client.Role.
		Create().
		SetTitle("@everyone").
		SetColor("#99AAB5").
		SetCommunityRolesManagement(false).
		SetCommunityUserBan(false).
		SetCommunityUserMute(false).
		SetCommunityDeletePost(false).
		SetCommunityDeleteComments(false).
		SetCommunityRemovePostFromPublication(false).
		SetCommunityID(newComm.ID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create @everyone role: %w", err)
	}

	// Назначаем роль "@everyone" создателю сообщества
	ownerID, _ := strconv.Atoi(input.OwnerID)
	_, err = r.Client.Role.
		UpdateOne(everyoneRole).
		AddUserIDs(ownerID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to assign @everyone role to owner: %w", err)
	}

	return newComm, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input models.CreateCommentInput) (*ent.Comment, error) {
	authorID, err := strconv.Atoi(input.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("invalid authorID %q: %w", input.AuthorID, err)
	}
	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID %q: %w", input.CommunityID, err)
	}
	postID, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID %q: %w", input.PostID, err)
	}

	var parentID *int
	if input.ParentCommentID != nil {
		pid, err := strconv.Atoi(*input.ParentCommentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parentCommentID %q: %w", *input.ParentCommentID, err)
		}
		parentID = &pid
	}
	// 1) Создаём комментарий
	c, err := r.Client.Comment.
		Create().
		SetAuthorID(authorID).
		SetCommunityID(communityID).
		SetPostID(postID).
		SetContent(input.Content).
		SetNillableParentCommentID(parentID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("create comment: %w", err)
	}

	// 2) Публикуем событие для подписок
	publishCommentAdded(postID, c)

	return c, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, input models.UpdateCommentInput) (*ent.Comment, error) {
	// 1) Парсим строковый ID в int
	cid, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid comment ID %q: %w", input.ID, err)
	}

	// 2) Начинаем билд запроса на обновление одной записи
	update := r.Client.Comment.
		UpdateOneID(cid)

	// 3) Если клиент передал hasDeleted = true (удаление комментария)
	if input.HasDeleted != nil && *input.HasDeleted {
		update = update.
			SetHasDeleted(true).
			SetContent("Комментарий был удален").
			// очищаем любое ранее прикреплённое медиа
			ClearMediaID()
	} else {
		// 4) Обновляем контент, если он пришёл
		if input.Content != nil {
			update = update.
				SetContent(*input.Content).
				SetHasUpdated(true)
		}
		// 5) Если пришёл новый mediaID — обновляем
		if input.MediaID != nil {
			mid, err := strconv.Atoi(*input.MediaID)
			if err != nil {
				return nil, fmt.Errorf("invalid media ID %q: %w", *input.MediaID, err)
			}
			update = update.SetMediaID(mid)
		}
	}

	// 6) Сохраняем и возвращаем обновлённый комментарий
	comment, err := update.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update comment %d: %w", cid, err)
	}

	// 7) Публикуем обновление для подписчиков
	publishCommentUpdated(comment.PostID, comment)

	return comment, nil
}

// Мутация LoginUser вызывает gRPC методы авторизации юзера
func (r *mutationResolver) LoginUser(ctx context.Context, input models.LoginUserInput) (*models.LoginUserResponse, error) {
	// Вызываем gRPC-метод Login
	resp, err := r.AuthClient.Login(ctx, &authpb.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		log.Printf("❌ [LoginUser] gRPC Login error: %v", err)
		return nil, err
	}

	// Мапим gRPC-пользователя в GraphQL-пользователя
	user, err := sharedmapper.ProtoToGraphQLUser(resp.User)
	if err != nil {
		log.Printf("❌ [LoginUser] Failed to map user: %v", err)
		return nil, status.Errorf(codes.Internal, "failed to map user: %v", err)
	}

	// Ставим куки в HTTP-ответе
	if w := httpWithCookies.GetHTTPResponseWriter(ctx); w != nil {
		httpWithCookies.SetAuthCookies(w, resp.AccessToken, resp.RefreshToken)
		log.Println("✅ [LoginUser] Cookies set successfully")
	} else {
		log.Println("⚠️ [LoginUser] HTTP response writer not found, cookies not set")
	}

	return &models.LoginUserResponse{
		AccessToken:  "",
		RefreshToken: "",
		User:         user,
	}, nil
}

// Мутация LogoutUser удаляет куки и сессию у авторизованного пользователя.
func (r *mutationResolver) LogoutUser(ctx context.Context) (*models.LogoutUserResponse, error) {
	// Извлекаем заголовок Authorization
	authHeader, _ := ctx.Value("authorization").(string)
	if authHeader != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", authHeader)
	}

	// Вызываем gRPC-метод Logout
	resp, err := r.AuthClient.Logout(ctx, &emptypb.Empty{})
	if err != nil {
		log.Printf("❌ [LogoutUser] gRPC Logout error: %v", err)
		return nil, err
	}

	// Очищаем HTTP-куки
	if w := httpWithCookies.GetHTTPResponseWriter(ctx); w != nil {
		httpWithCookies.ClearAuthCookies(w)
		log.Println("✅ [LogoutUser] Cookies cleared successfully")
	} else {
		log.Println("⚠️ [LogoutUser] HTTP response writer not found, cookies not cleared")
	}

	return &models.LogoutUserResponse{
		Message: resp.Message,
	}, nil
}

// Мутация RegisterUser вызывает gRPC методы для регистрации пользователей.
func (r *mutationResolver) RegisterUser(ctx context.Context, input models.RegisterUserInput) (*models.RegisterUserResponse, error) {
	// Проверяем входные данные
	if input.Name == "" || input.Email == "" || input.Password == "" {
		log.Println("❌ [RegisterUser] Missing required fields")
		return nil, errors.New("name, email, and password are required")
	}

	// Вызываем gRPC-метод RegisterUser
	resp, err := r.UserClient.RegisterUser(ctx, &userpb.RegisterUserRequest{
		Name:     input.Name,
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		log.Printf("❌ [RegisterUser] gRPC RegisterUser error: %v", err)
		return nil, err
	}

	// Формируем ответ GraphQL
	return &models.RegisterUserResponse{
		Message: resp.Message,
	}, nil
}

// Мутация UserVerifyEmail проверяет токен из письма и подтверждает статус юзера.
func (r *mutationResolver) UserVerifyEmail(ctx context.Context, input models.VerifyEmailInput) (*models.VerifyEmailResponse, error) {
	// Проверяем входной токен
	if input.Token == "" {
		log.Println("❌ [UserVerifyEmail] Token is required")
		return nil, errors.New("token is required")
	}

	// Вызываем gRPC-метод VerifyEmail
	resp, err := r.MailClient.VerifyEmail(ctx, &mailpb.VerifyEmailRequest{
		Token: input.Token,
	})
	if err != nil {
		log.Printf("❌ [UserVerifyEmail] gRPC VerifyEmail error: %v", err)
		return nil, err
	}

	return &models.VerifyEmailResponse{
		Message: resp.Message,
	}, nil
}

// ResendUserVerifyEmail is the resolver for the resendUserVerifyEmail field.
func (r *mutationResolver) ResendUserVerifyEmail(ctx context.Context, input models.ResendVerifyEmailInput) (*models.ResendVerifyEmailResponse, error) {
	panic(fmt.Errorf("not implemented: ResendUserVerifyEmail - resendUserVerifyEmail"))
}

// Мутация UserRefreshToken обновляет сессию пользователя.
func (r *mutationResolver) UserRefreshToken(ctx context.Context) (*models.RefreshTokenResponse, error) {
	// 1. Извлекаем HTTP-запрос из контекста, чтобы достать cookie
	httpReq := httpWithCookies.GetHTTPRequest(ctx)
	var refreshToken string
	if httpReq != nil {
		if cookie, err := httpReq.Cookie("refresh_token"); err == nil {
			refreshToken = cookie.Value
		}
	}

	// Если в куке нет refresh_token, попробуем взять его из входящих аргументов (если вы где-то передаёте)
	// Но раз у вас прототип не принимает аргументы, достаточно из cookie.

	if refreshToken == "" {
		return nil, fmt.Errorf("refresh token is missing")
	}

	// 2. Приклеиваем Authorization (опционально, только если он нужен внутри gRPC-RefreshToken)
	authHeader, _ := ctx.Value("authorization").(string)
	if authHeader != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", authHeader)
	}

	// 3. Вызываем gRPC-метод с заполненным refreshToken
	resp, err := r.AuthClient.RefreshToken(ctx, &authpb.RefreshTokenRequest{
		RefreshToken: refreshToken,
	})
	if err != nil {
		log.Printf("❌ [UserRefreshToken] gRPC RefreshToken error: %v", err)
		return nil, err
	}

	// 4. Ставим новые куки
	if w := httpWithCookies.GetHTTPResponseWriter(ctx); w != nil {
		httpWithCookies.SetAuthCookies(w, resp.AccessToken, resp.RefreshToken)
		log.Println("✅ [UserRefreshToken] Cookies set successfully")
	} else {
		log.Println("⚠️ [UserRefreshToken] HTTP response writer not found, cookies not set")
	}

	return &models.RefreshTokenResponse{
		AccessToken:  "",
		RefreshToken: "",
	}, nil
}

// UploadMedia is the resolver for the uploadMedia field.
func (r *mutationResolver) UploadMedia(ctx context.Context, file graphql.Upload, dir *string) (*ent.Media, error) {
	// 1) Читаем содержимое файла с ограничением размера и базовой валидацией MIME
	maxUpload := int64(20 * 1024 * 1024) // 20MB по умолчанию
	if v := os.Getenv("UPLOAD_MAX_BYTES"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n > 0 {
			maxUpload = int64(n)
		}
	}
	limited := io.LimitReader(file.File, maxUpload+1)
	var buf bytes.Buffer
	if _, err := io.Copy(&buf, limited); err != nil {
		return nil, fmt.Errorf("failed to read uploaded file: %w", err)
	}
	if int64(buf.Len()) > maxUpload {
		return nil, fmt.Errorf("file too large")
	}
	content := buf.Bytes()
	// Проверяем content-type по сигнатуре
	ct := http.DetectContentType(content)
	switch ct {
	case "image/jpeg", "image/png", "image/gif":
	default:
		return nil, fmt.Errorf("unsupported content type: %s", ct)
	}

	// 2) Прокидываем Authorization из контекста, если есть
	if authHeader, _ := ctx.Value("authorization").(string); authHeader != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", authHeader)
	}

	// 3) Формируем gRPC-запрос
	grpcReq := &mediapb.UploadMediaRequest{
		Dir:         "media",
		Filename:    file.Filename,
		FileContent: content,
	}
	if dir != nil && *dir != "" {
		grpcReq.Dir = *dir
	}

	// 4) Вызываем gRPC
	resp, err := r.MediaClient.UploadMedia(ctx, grpcReq)
	if err != nil {
		log.Printf("❌ gRPC UploadMedia error: %v", err)
		return nil, fmt.Errorf("gRPC UploadMedia error: %w", err)
	}

	// 5) Конвертируем ответ в ent.Media (*string поля)
	fileName := resp.GetFilename()
	URL := resp.GetUrl()
	return &ent.Media{
		ID:       int(resp.GetId()),
		Filename: &fileName,
		URL:      &URL,
	}, nil
}

// FollowUser мутация подписки на пользователя.
func (r *mutationResolver) FollowUser(ctx context.Context, input models.FollowUserInput) (*models.UserStatus, error) {
	// 1) Узнаём currentUserID
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	// 2) Создаём запись в user_follow
	uID, _ := strconv.Atoi(input.UserID)
	_, err = r.Client.UserFollow.
		Create().
		SetFollowerID(currentUserID).
		SetFolloweeID(uID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed follow: %w", err)
	}
	// 3) Возвращаем актуальный UserStatus (используя ваш usecase)
	status, err := r.UserUC.GetUserStatus(ctx, currentUserID, uID)
	if err != nil {
		return nil, fmt.Errorf("refresh status: %w", err)
	}
	return status, nil
}

// UnfollowUser мутация отписки от пользователя.
func (r *mutationResolver) UnfollowUser(ctx context.Context, input models.UnfollowUserInput) (*models.UserStatus, error) {
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	// Удаляем запись
	uID, _ := strconv.Atoi(input.UserID)
	_, err = r.Client.UserFollow.
		Delete().
		Where(
			userfollow.FollowerIDEQ(currentUserID),
			userfollow.FolloweeIDEQ(uID),
		).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed unfollow: %w", err)
	}
	status, err := r.UserUC.GetUserStatus(ctx, currentUserID, uID)
	if err != nil {
		return nil, fmt.Errorf("refresh status: %w", err)
	}
	return status, nil
}

// FollowCommunity мутация подписки на сообщество.
func (r *mutationResolver) FollowCommunity(ctx context.Context, input models.FollowCommunityInput) (*models.CommunityStatus, error) {
	// 1) Узнаём currentUserID
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// 2) Создаём запись в community_follow
	cID, _ := strconv.Atoi(input.CommunityID)
	_, err = r.Client.CommunityFollow.
		Create().
		SetUserID(currentUserID).
		SetCommunityID(cID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed follow: %w", err)
	}

	// 3) Автоматически назначаем роль "@everyone" новому участнику
	everyoneRole, err := r.Client.Role.
		Query().
		Where(
			role.TitleEQ("@everyone"),
			role.CommunityIDEQ(cID),
		).
		Only(ctx)
	if err != nil {
		// Если роль "@everyone" не найдена, создаем её
		everyoneRole, err = r.Client.Role.
			Create().
			SetTitle("@everyone").
			SetColor("#99AAB5").
			SetCommunityRolesManagement(false).
			SetCommunityUserBan(false).
			SetCommunityUserMute(false).
			SetCommunityDeletePost(false).
			SetCommunityDeleteComments(false).
			SetCommunityRemovePostFromPublication(false).
			SetCommunityID(cID).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to create @everyone role: %w", err)
		}
	}

	// Добавляем пользователя в роль "@everyone"
	_, err = r.Client.Role.
		UpdateOne(everyoneRole).
		AddUserIDs(currentUserID).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to assign @everyone role: %w", err)
	}

	// 4) Возвращаем актуальный CommunityStatus (используя ваш usecase)
	status, err := r.CommunityUC.GetCommunityStatus(ctx, currentUserID, cID)
	if err != nil {
		return nil, fmt.Errorf("refresh status: %w", err)
	}
	return status, nil
}

// UnfollowCommunity мутация отписки от сообщества.
func (r *mutationResolver) UnfollowCommunity(ctx context.Context, input models.UnfollowCommunityInput) (*models.CommunityStatus, error) {
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	// Удаляем запись
	cID, _ := strconv.Atoi(input.CommunityID)
	_, err = r.Client.CommunityFollow.
		Delete().
		Where(
			communityfollow.UserIDEQ(currentUserID),
			communityfollow.CommunityIDEQ(cID),
		).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed unfollow: %w", err)
	}
	status, err := r.CommunityUC.GetCommunityStatus(ctx, currentUserID, cID)
	if err != nil {
		return nil, fmt.Errorf("refresh status: %w", err)
	}
	return status, nil
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, input models.LikePostInput) (*models.PostStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	pid, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	// idempotent: если уже лайкнул — не дублируем
	exists, err := r.Client.PostLike.Query().Where(postlike.UserIDEQ(userID), postlike.PostIDEQ(pid)).Exist(ctx)
	if err != nil {
		return nil, fmt.Errorf("like exists: %w", err)
	}
	if !exists {
		if _, err := r.Client.PostLike.Create().SetUserID(userID).SetPostID(pid).Save(ctx); err != nil {
			return nil, fmt.Errorf("like create: %w", err)
		}
	}
	return r.PostUC.GetPostStatus(ctx, userID, pid)
}

// UnlikePost is the resolver for the unlikePost field.
func (r *mutationResolver) UnlikePost(ctx context.Context, input models.UnlikePostInput) (*models.PostStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	pid, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	if _, err := r.Client.PostLike.Delete().Where(postlike.UserIDEQ(userID), postlike.PostIDEQ(pid)).Exec(ctx); err != nil {
		return nil, fmt.Errorf("like delete: %w", err)
	}
	return r.PostUC.GetPostStatus(ctx, userID, pid)
}

// LikeComment is the resolver for the likeComment field.
func (r *mutationResolver) LikeComment(ctx context.Context, input models.LikeCommentInput) (*models.CommentStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	cid, err := strconv.Atoi(input.CommentID)
	if err != nil {
		return nil, fmt.Errorf("invalid commentID: %w", err)
	}
	// idempotent: если уже лайкнул — не дублируем
	exists, err := r.Client.CommentLike.Query().Where(commentlike.UserIDEQ(userID), commentlike.CommentIDEQ(cid)).Exist(ctx)
	if err != nil {
		return nil, fmt.Errorf("like exists: %w", err)
	}
	if !exists {
		if _, err := r.Client.CommentLike.Create().SetUserID(userID).SetCommentID(cid).Save(ctx); err != nil {
			return nil, fmt.Errorf("like create: %w", err)
		}
	}
	return r.CommentUC.GetCommentStatus(ctx, userID, cid)
}

// UnlikeComment is the resolver for the unlikeComment field.
func (r *mutationResolver) UnlikeComment(ctx context.Context, input models.UnlikeCommentInput) (*models.CommentStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	cid, err := strconv.Atoi(input.CommentID)
	if err != nil {
		return nil, fmt.Errorf("invalid commentID: %w", err)
	}
	if _, err := r.Client.CommentLike.Delete().Where(commentlike.UserIDEQ(userID), commentlike.CommentIDEQ(cid)).Exec(ctx); err != nil {
		return nil, fmt.Errorf("like delete: %w", err)
	}
	return r.CommentUC.GetCommentStatus(ctx, userID, cid)
}

// AddBookmarkPost is the resolver for the addBookmarkPost field.
func (r *mutationResolver) AddBookmarkPost(ctx context.Context, input models.BookmarkPostInput) (*models.PostStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	pid, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	exists, err := r.Client.Bookmark.Query().Where(bookmark.UserIDEQ(userID), bookmark.PostIDEQ(pid)).Exist(ctx)
	if err != nil {
		return nil, fmt.Errorf("bookmark exists: %w", err)
	}
	if !exists {
		if _, err := r.Client.Bookmark.Create().SetUserID(userID).SetPostID(pid).Save(ctx); err != nil {
			return nil, fmt.Errorf("bookmark create: %w", err)
		}
	}
	return r.PostUC.GetPostStatus(ctx, userID, pid)
}

// DeleteBookmarkPost is the resolver for the deleteBookmarkPost field.
func (r *mutationResolver) DeleteBookmarkPost(ctx context.Context, input models.DeleteBookmarkPostInput) (*models.PostStatus, error) {
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	pid, err := strconv.Atoi(input.PostID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	if _, err := r.Client.Bookmark.Delete().Where(bookmark.UserIDEQ(userID), bookmark.PostIDEQ(pid)).Exec(ctx); err != nil {
		return nil, fmt.Errorf("bookmark delete: %w", err)
	}
	return r.PostUC.GetPostStatus(ctx, userID, pid)
}

// IncrementPostViews is the resolver for the incrementPostViews field.
func (r *mutationResolver) IncrementPostViews(ctx context.Context, postID string) (*ent.Post, error) {
	id, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	if rds, err := redisx.NewClient(); err == nil && rds != nil {
		key := fmt.Sprintf("view:post:%d", id)
		if uid, uerr := auth.UserIDFromContext(ctx); uerr == nil && uid > 0 {
			key += fmt.Sprintf(":u:%d", uid)
		} else if r := httpWithCookies.GetHTTPRequest(ctx); r != nil {
			key += ":" + r.RemoteAddr
		}
		if set := rds.SetNX(ctx, key, 1, 15*time.Minute); set.Err() == nil && !set.Val() {
			return r.Client.Post.Get(ctx, id)
		}
	}
	p, err := r.Client.Post.UpdateOneID(id).AddViews(1).Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("increment views: %w", err)
	}
	return p, nil
}

// Community is the resolver for the community field.
func (r *mutationResolver) Community(ctx context.Context, input models.UpdateCommunityInput) (*ent.Community, error) {
	// Авторизация: владелец сообщества или менеджер ролей сообщества
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	cid, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid community ID %q: %w", input.ID, err)
	}

	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden")
		}
	}

	upd := r.Client.Community.UpdateOneID(cid)
	if input.Title != nil {
		upd = upd.SetTitle(*input.Title)
	}
	if input.Description != nil {
		upd = upd.SetDescription(*input.Description)
	}
	if input.Contacts != nil {
		upd = upd.SetContacts(*input.Contacts)
	}
	if input.LogoID != nil {
		lid, err := strconv.Atoi(*input.LogoID)
		if err != nil {
			return nil, fmt.Errorf("invalid logoID: %w", err)
		}
		upd = upd.SetLogoID(lid)
	}
	if input.BannerID != nil {
		bid, err := strconv.Atoi(*input.BannerID)
		if err != nil {
			return nil, fmt.Errorf("invalid bannerID: %w", err)
		}
		upd = upd.SetBannerID(bid)
	}

	if input.Slug != nil {
		if cm.OwnerID != currentUserID {
			return nil, fmt.Errorf("forbidden: only owner can change slug")
		}
		newSlug := slug.Make(*input.Slug)
		if newSlug == "" {
			return nil, fmt.Errorf("bad_request: empty slug")
		}
		exists, err := r.Client.Community.Query().Where(community.SlugEQ(newSlug), community.IDNEQ(cid)).Exist(ctx)
		if err != nil {
			return nil, err
		}
		if exists {
			return nil, fmt.Errorf("bad_request: slug already taken")
		}
		upd = upd.SetSlug(newSlug)
	}
	return upd.Save(ctx)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input models.UpdateUserInput) (*models.UserResponse, error) {
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	uid, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID %q: %w", input.ID, err)
	}
	if uid != currentUserID {
		return nil, fmt.Errorf("forbidden")
	}

	upd := r.Client.User.UpdateOneID(uid)
	if input.Name != nil {
		upd = upd.SetName(*input.Name)
	}
	if input.Description != nil {
		upd = upd.SetDescription(*input.Description)
	}
	if input.AvatarID != nil {
		aid, err := strconv.Atoi(*input.AvatarID)
		if err != nil {
			return nil, fmt.Errorf("invalid avatarID: %w", err)
		}
		upd = upd.SetAvatarID(aid)
	}
	if input.Slug != nil {
		newSlug := slug.Make(*input.Slug)
		if newSlug == "" {
			return nil, fmt.Errorf("bad_request: empty slug")
		}
		exists, err := r.Client.User.Query().Where(user.SlugEQ(newSlug), user.IDNEQ(uid)).Exist(ctx)
		if err != nil {
			return nil, err
		}
		if exists {
			return nil, fmt.Errorf("bad_request: slug already taken")
		}
		upd = upd.SetSlug(newSlug)
	}
	if _, err := upd.Save(ctx); err != nil {
		return nil, err
	}

	// Upsert произвольных info
	if input.Info != nil {
		for _, kv := range input.Info {
			if kv == nil {
				continue
			}
			ex, err := r.Client.ProfileTableInfoItem.Query().
				Where(
					profiletableinfoitem.UserIDEQ(uid),
					profiletableinfoitem.KeyEQ(kv.Key),
					profiletableinfoitem.TypeEQ(profiletableinfoitem.TypeUser),
				).Only(ctx)
			if ent.IsNotFound(err) {
				if _, err := r.Client.ProfileTableInfoItem.Create().SetUserID(uid).SetType(profiletableinfoitem.TypeUser).SetKey(kv.Key).SetValue(kv.Value).Save(ctx); err != nil {
					return nil, err
				}
			} else if err == nil {
				if _, err := r.Client.ProfileTableInfoItem.UpdateOneID(ex.ID).SetValue(kv.Value).Save(ctx); err != nil {
					return nil, err
				}
			} else {
				return nil, err
			}
		}
	}

	if authHeader, ok := ctx.Value("authorization").(string); ok && authHeader != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", authHeader)
	}
	resp, err := r.AuthClient.GetMe(ctx, &emptypb.Empty{})
	if err != nil {
		return nil, err
	}
	mapped, err := sharedmapper.ProtoToGraphQLUser(resp.User)
	if err != nil {
		return nil, err
	}
	return mapped, nil
}

// UpdateHostSocialNavigation is the resolver for the updateHostSocialNavigation field.
func (r *mutationResolver) UpdateHostSocialNavigation(ctx context.Context, input models.UpdateHostSocialNavigationInput) (*ent.HostSocialNavigation, error) {
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		return nil, fmt.Errorf("forbidden")
	}

	upd := r.Client.HostSocialNavigation.UpdateOneID(1)
	if input.Github != nil {
		upd = upd.SetGithub(*input.Github)
	}
	if input.Site != nil {
		upd = upd.SetSite(*input.Site)
	}
	if input.Telegram != nil {
		upd = upd.SetTelegram(*input.Telegram)
	}
	if input.Instagram != nil {
		upd = upd.SetInstagram(*input.Instagram)
	}
	if input.Twitter != nil {
		upd = upd.SetTwitter(*input.Twitter)
	}
	if input.Mastodon != nil {
		upd = upd.SetMastodon(*input.Mastodon)
	}
	return upd.Save(ctx)
}

// CreateHostRole is the resolver for the createHostRole field.
func (r *mutationResolver) CreateHostRole(ctx context.Context, input models.CreateHostRoleInput) (*ent.HostRole, error) {
	// Проверяем права: только владелец платформы
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		return nil, fmt.Errorf("forbidden: only host owner can create roles")
	}

	return r.HostRoleUC.CreateHostRole(ctx, &input)
}

// UpdateHostRole is the resolver for the updateHostRole field.
func (r *mutationResolver) UpdateHostRole(ctx context.Context, input models.UpdateHostRoleInput) (*ent.HostRole, error) {
	// Проверяем права: только владелец платформы
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		return nil, fmt.Errorf("forbidden: only host owner can update roles")
	}

	return r.HostRoleUC.UpdateHostRole(ctx, &input)
}

// DeleteHostRole is the resolver for the deleteHostRole field.
func (r *mutationResolver) DeleteHostRole(ctx context.Context, id string) (bool, error) {
	// Проверяем права: только владелец платформы
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return false, err
	}
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		return false, fmt.Errorf("forbidden: only host owner can delete roles")
	}

	roleID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid role ID: %w", err)
	}

	err = r.HostRoleUC.DeleteHostRole(ctx, roleID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateCommunityRole is the resolver for the createCommunityRole field.
func (r *mutationResolver) CreateCommunityRole(ctx context.Context, input models.CreateCommunityRoleInput) (*ent.Role, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, communityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{communityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[communityID]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can create roles")
		}
	}

	return r.CommunityRoleUC.CreateCommunityRole(ctx, &input)
}

// UpdateCommunityRole is the resolver for the updateCommunityRole field.
func (r *mutationResolver) UpdateCommunityRole(ctx context.Context, input models.UpdateCommunityRoleInput) (*ent.Role, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	roleID, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid role ID: %w", err)
	}

	// Получаем роль для проверки сообщества
	role, err := r.Client.Role.Get(ctx, roleID)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, role.CommunityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{role.CommunityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[role.CommunityID]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can update roles")
		}
	}

	return r.CommunityRoleUC.UpdateCommunityRole(ctx, &input)
}

// DeleteCommunityRole is the resolver for the deleteCommunityRole field.
func (r *mutationResolver) DeleteCommunityRole(ctx context.Context, id string) (bool, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	roleID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid role ID: %w", err)
	}

	// Получаем роль для проверки сообщества
	role, err := r.Client.Role.Get(ctx, roleID)
	if err != nil {
		return false, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, role.CommunityID)
	if err != nil {
		return false, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{role.CommunityID})
		if err != nil {
			return false, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[role.CommunityID]
		if perms == nil || !perms.CommunityRolesManagement {
			return false, fmt.Errorf("forbidden: only owner or role manager can delete roles")
		}
	}

	err = r.CommunityRoleUC.DeleteCommunityRole(ctx, roleID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// BanUserFromHost is the resolver for the banUserFromHost field.
func (r *mutationResolver) BanUserFromHost(ctx context.Context, input models.BanUserInput) (*ent.HostUserBan, error) {
	// Проверяем права: только владелец платформы или пользователи с hostUserBan
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return nil, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostUserBan {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return nil, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	userID, err := strconv.Atoi(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid userID: %w", err)
	}

	return r.BanUC.BanUserFromHost(ctx, userID, 1) // hostID всегда 1
}

// UnbanUserFromHost is the resolver for the unbanUserFromHost field.
func (r *mutationResolver) UnbanUserFromHost(ctx context.Context, banID string) (bool, error) {
	// Проверяем права: только владелец платформы или пользователи с hostUserBan
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return false, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return false, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostUserBan {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return false, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	id, err := strconv.Atoi(banID)
	if err != nil {
		return false, fmt.Errorf("invalid banID: %w", err)
	}

	err = r.BanUC.UnbanUserFromHost(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// BanCommunityFromHost is the resolver for the banCommunityFromHost field.
func (r *mutationResolver) BanCommunityFromHost(ctx context.Context, input models.BanCommunityInput) (*models.HostCommunityBan, error) {
	// Проверяем права: только владелец платформы или пользователи с hostCommunityDeletePost
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return nil, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostCommunityDeletePost {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return nil, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	ban, err := r.BanUC.BanCommunityFromHost(ctx, communityID, 1) // hostID всегда 1
	if err != nil {
		return nil, err
	}

	// Маппинг ent -> models
	return &models.HostCommunityBan{
		ID:          strconv.Itoa(ban.ID),
		CommunityID: strconv.Itoa(ban.CommunityID),
		CreatedAt:   ban.CreatedAt,
		UpdatedAt:   ban.UpdatedAt,
	}, nil
}

// UnbanCommunityFromHost is the resolver for the unbanCommunityFromHost field.
func (r *mutationResolver) UnbanCommunityFromHost(ctx context.Context, banID string) (bool, error) {
	// Проверяем права: только владелец платформы или пользователи с hostCommunityDeletePost
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return false, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return false, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostCommunityDeletePost {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return false, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	id, err := strconv.Atoi(banID)
	if err != nil {
		return false, fmt.Errorf("invalid banID: %w", err)
	}

	err = r.BanUC.UnbanCommunityFromHost(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// BanUserFromCommunity is the resolver for the banUserFromCommunity field.
func (r *mutationResolver) BanUserFromCommunity(ctx context.Context, input models.BanUserInput) (*ent.CommunityUserBan, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserBan
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	if input.CommunityID == nil {
		return nil, fmt.Errorf("communityID is required")
	}

	communityID, err := strconv.Atoi(*input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, communityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{communityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[communityID]
		if perms == nil || !perms.CommunityUserBan {
			return nil, fmt.Errorf("forbidden: only owner or users with ban permission can ban users")
		}
	}

	userID, err := strconv.Atoi(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid userID: %w", err)
	}

	return r.BanUC.BanUserFromCommunity(ctx, userID, communityID)
}

// UnbanUserFromCommunity is the resolver for the unbanUserFromCommunity field.
func (r *mutationResolver) UnbanUserFromCommunity(ctx context.Context, banID string) (bool, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserBan
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	id, err := strconv.Atoi(banID)
	if err != nil {
		return false, fmt.Errorf("invalid banID: %w", err)
	}

	// Получаем бан для проверки сообщества
	ban, err := r.Client.CommunityUserBan.Get(ctx, id)
	if err != nil {
		return false, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, ban.CommunityID)
	if err != nil {
		return false, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{ban.CommunityID})
		if err != nil {
			return false, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[ban.CommunityID]
		if perms == nil || !perms.CommunityUserBan {
			return false, fmt.Errorf("forbidden: only owner or users with ban permission can unban users")
		}
	}

	err = r.BanUC.UnbanUserFromCommunity(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// MuteUserInCommunity is the resolver for the muteUserInCommunity field.
func (r *mutationResolver) MuteUserInCommunity(ctx context.Context, input models.MuteUserInput) (*ent.CommunityUserMute, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserMute
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, communityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{communityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[communityID]
		if perms == nil || !perms.CommunityUserMute {
			return nil, fmt.Errorf("forbidden: only owner or users with mute permission can mute users")
		}
	}

	userID, err := strconv.Atoi(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid userID: %w", err)
	}

	return r.BanUC.MuteUserInCommunity(ctx, userID, communityID)
}

// UnmuteUserInCommunity is the resolver for the unmuteUserInCommunity field.
func (r *mutationResolver) UnmuteUserInCommunity(ctx context.Context, muteID string) (bool, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserMute
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	id, err := strconv.Atoi(muteID)
	if err != nil {
		return false, fmt.Errorf("invalid muteID: %w", err)
	}

	// Получаем мут для проверки сообщества
	mute, err := r.Client.CommunityUserMute.Get(ctx, id)
	if err != nil {
		return false, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, mute.CommunityID)
	if err != nil {
		return false, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{mute.CommunityID})
		if err != nil {
			return false, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[mute.CommunityID]
		if perms == nil || !perms.CommunityUserMute {
			return false, fmt.Errorf("forbidden: only owner or users with mute permission can unmute users")
		}
	}

	err = r.BanUC.UnmuteUserInCommunity(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateProfileTableInfoItem is the resolver for the createProfileTableInfoItem field.
func (r *mutationResolver) CreateProfileTableInfoItem(ctx context.Context, input models.CreateProfileTableInfoItemInput) (*ent.ProfileTableInfoItem, error) {
	// Проверяем авторизацию
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	// Проверяем права в зависимости от типа
	if input.Type == "community" && input.CommunityID != nil {
		cid, err := strconv.Atoi(*input.CommunityID)
		if err != nil {
			return nil, fmt.Errorf("invalid communityID: %w", err)
		}

		// Проверяем права на сообщество
		cm, err := r.Client.Community.Get(ctx, cid)
		if err != nil {
			return nil, fmt.Errorf("community not found: %w", err)
		}

		if cm.OwnerID != currentUserID {
			permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
			if err != nil {
				return nil, fmt.Errorf("permissions: %w", err)
			}
			perms := permsMap[cid]
			if perms == nil || !perms.CommunityRolesManagement {
				return nil, fmt.Errorf("forbidden: only owner or role manager can create profile info items")
			}
		}
	} else if input.Type == "user" && input.UserID != nil {
		uid, err := strconv.Atoi(*input.UserID)
		if err != nil {
			return nil, fmt.Errorf("invalid userID: %w", err)
		}

		// Пользователь может создавать элементы только для своего профиля
		if uid != currentUserID {
			return nil, fmt.Errorf("forbidden: can only create profile info items for own profile")
		}
	} else {
		return nil, fmt.Errorf("invalid input: must specify either communityID or userID")
	}

	return r.ProfileTableInfoItemUC.CreateProfileTableInfoItem(ctx, &input)
}

// UpdateProfileTableInfoItem is the resolver for the updateProfileTableInfoItem field.
func (r *mutationResolver) UpdateProfileTableInfoItem(ctx context.Context, input models.UpdateProfileTableInfoItemInput) (*ent.ProfileTableInfoItem, error) {
	// Проверяем авторизацию
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	itemID, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid ID: %w", err)
	}

	// Получаем элемент для проверки прав
	item, err := r.ProfileTableInfoItemUC.GetProfileTableInfoItem(ctx, itemID)
	if err != nil {
		return nil, fmt.Errorf("profile info item not found: %w", err)
	}

	// Проверяем права в зависимости от типа
	if item.Type == "community" && item.CommunityID != 0 {
		// Проверяем права на сообщество
		cm, err := r.Client.Community.Get(ctx, item.CommunityID)
		if err != nil {
			return nil, fmt.Errorf("community not found: %w", err)
		}

		if cm.OwnerID != currentUserID {
			permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{item.CommunityID})
			if err != nil {
				return nil, fmt.Errorf("permissions: %w", err)
			}
			perms := permsMap[item.CommunityID]
			if perms == nil || !perms.CommunityRolesManagement {
				return nil, fmt.Errorf("forbidden: only owner or role manager can update profile info items")
			}
		}
	} else if item.Type == "user" && item.UserID != 0 {
		// Пользователь может обновлять элементы только своего профиля
		if item.UserID != currentUserID {
			return nil, fmt.Errorf("forbidden: can only update own profile info items")
		}
	}

	return r.ProfileTableInfoItemUC.UpdateProfileTableInfoItem(ctx, &input)
}

// DeleteProfileTableInfoItem is the resolver for the deleteProfileTableInfoItem field.
func (r *mutationResolver) DeleteProfileTableInfoItem(ctx context.Context, id string) (bool, error) {
	// Проверяем авторизацию
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated")
	}

	itemID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid ID: %w", err)
	}

	// Получаем элемент для проверки прав
	item, err := r.ProfileTableInfoItemUC.GetProfileTableInfoItem(ctx, itemID)
	if err != nil {
		return false, fmt.Errorf("profile info item not found: %w", err)
	}

	// Проверяем права в зависимости от типа
	if item.Type == "community" && item.CommunityID != 0 {
		// Проверяем права на сообщество
		cm, err := r.Client.Community.Get(ctx, item.CommunityID)
		if err != nil {
			return false, fmt.Errorf("community not found: %w", err)
		}

		if cm.OwnerID != currentUserID {
			permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{item.CommunityID})
			if err != nil {
				return false, fmt.Errorf("permissions: %w", err)
			}
			perms := permsMap[item.CommunityID]
			if perms == nil || !perms.CommunityRolesManagement {
				return false, fmt.Errorf("forbidden: only owner or role manager can delete profile info items")
			}
		}
	} else if item.Type == "user" && item.UserID != 0 {
		// Пользователь может удалять элементы только своего профиля
		if item.UserID != currentUserID {
			return false, fmt.Errorf("forbidden: can only delete own profile info items")
		}
	}

	err = r.ProfileTableInfoItemUC.DeleteProfileTableInfoItem(ctx, itemID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateCommunityRule is the resolver for the createCommunityRule field.
func (r *mutationResolver) CreateCommunityRule(ctx context.Context, input models.CreateCommunityRuleInput) (*ent.CommunityRule, error) {
	return r.CommunityRuleUsecase.CreateCommunityRule(ctx, &input)
}

// UpdateCommunityRule is the resolver for the updateCommunityRule field.
func (r *mutationResolver) UpdateCommunityRule(ctx context.Context, input models.UpdateCommunityRuleInput) (*ent.CommunityRule, error) {
	return r.CommunityRuleUsecase.UpdateCommunityRule(ctx, &input)
}

// DeleteCommunityRule is the resolver for the deleteCommunityRule field.
func (r *mutationResolver) DeleteCommunityRule(ctx context.Context, id string) (bool, error) {
	return r.CommunityRuleUsecase.DeleteCommunityRule(ctx, id)
}

// PostStatus is the resolver for the postStatus field.
func (r *postResolver) PostStatus(ctx context.Context, obj *ent.Post) (*models.PostStatus, error) {
	// Берём текущего пользователя из контекста, для корректного isLiked/hasBookmark
	uid := 0
	if id, err := auth.UserIDFromContext(ctx); err == nil {
		uid = id
	}
	return r.PostUC.GetPostStatus(ctx, uid, obj.ID)
}

// Media возвращает медиа по ID.
func (r *queryResolver) Media(ctx context.Context, id string) (*ent.Media, error) {
	mediaId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Media.Get(ctx, mediaId)
}

// Community отдает одно сообщество по ID.
func (r *queryResolver) Community(ctx context.Context, id string) (*ent.Community, error) {
	communityId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Community.Get(ctx, communityId)
}

// CommunityBySlug отдает одно сообщество по slug.
func (r *queryResolver) CommunityBySlug(ctx context.Context, slug string) (*ent.Community, error) {
	return r.Client.Community.
		Query().
		Where(community.SlugEQ(slug)).
		WithLogo().
		WithBanner().
		WithOwner().
		WithModerators().
		WithRules().
		WithCommunityInfo().
		WithRoles().
		Only(ctx)
}

// Communities возвращает все или только не забаненные сообщества.
func (r *queryResolver) Communities(ctx context.Context, onlyNotBanned *bool) ([]*ent.Community, error) {
	q := r.Client.Community.Query()
	if onlyNotBanned == nil || *onlyNotBanned {
		q = q.Where(community.CommunityHasBanned(false))
	}
	return q.Order(ent.Asc("id")).All(ctx)
}

// CommunityUserBan отдает запись о бане юзера по userID и communityID.
func (r *queryResolver) CommunityUserBan(ctx context.Context, communityID string, userID string) (*ent.CommunityUserBan, error) {
	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, err
	}
	uid, err := strconv.Atoi(userID)
	if err != nil {
		return nil, err
	}
	ban, err := r.Client.CommunityUserBan.
		Query().
		Where(
			communityuserban.CommunityIDEQ(cid),
			communityuserban.UserIDEQ(uid),
		).
		Only(ctx)
	if ent.IsNotFound(err) {
		return nil, nil
	}
	return ban, err
}

// CommunityUserMute отдает запись о муте юзера по userID и communityID.
func (r *queryResolver) CommunityUserMute(ctx context.Context, communityID string, userID string) (*ent.CommunityUserMute, error) {
	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, err
	}
	uid, err := strconv.Atoi(userID)
	if err != nil {
		return nil, err
	}
	mute, err := r.Client.CommunityUserMute.
		Query().
		Where(
			communityusermute.CommunityIDEQ(cid),
			communityusermute.UserIDEQ(uid),
		).
		Only(ctx)
	if ent.IsNotFound(err) {
		return nil, nil
	}
	return mute, err
}

// CommunityModerator is the resolver for the communityModerator field.
func (r *queryResolver) CommunityModerator(ctx context.Context, communityID string, userID string) (*ent.CommunityModerator, error) {
	panic(fmt.Errorf("not implemented: CommunityModerator - communityModerator"))
}

// CommunityRule is the resolver for the communityRule field.
func (r *queryResolver) CommunityRule(ctx context.Context, id string) (*ent.CommunityRule, error) {
	return r.CommunityRuleUsecase.GetCommunityRule(ctx, id)
}

// CommunityRules is the resolver for the communityRules field.
func (r *queryResolver) CommunityRules(ctx context.Context, communityID string) ([]*ent.CommunityRule, error) {
	return r.CommunityRuleUsecase.GetCommunityRules(ctx, communityID)
}

// GetMe отдает текущего авторизованного пользователя.
func (r *queryResolver) GetMe(ctx context.Context) (*models.UserResponse, error) {
	// Извлекаем userID из контекста для проверки авторизации
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		log.Println("❌ GraphQL: unauthenticated, no userID in context")
		return nil, fmt.Errorf("unauthenticated")
	}

	log.Printf("✅ GraphQL GetMe: userID from context: %d", userID)

	// Извлекаем заголовок Authorization
	authHeader, ok := ctx.Value("authorization").(string)
	if !ok || authHeader == "" {
		log.Println("❌ GraphQL: missing authorization header")
		return nil, fmt.Errorf("missing authorization header")
	}

	// Добавляем Authorization в gRPC-метаданные
	ctx = metadata.AppendToOutgoingContext(ctx, "authorization", authHeader)

	// Вызываем gRPC-метод GetMe
	resp, err := r.AuthClient.GetMe(ctx, &emptypb.Empty{})
	if err != nil {
		log.Printf("❌ GraphQL: failed to call GetMe: %v", err)
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	// Мапим gRPC-пользователя в GraphQL-пользователя
	user, err := sharedmapper.ProtoToGraphQLUser(resp.User)
	if err != nil {
		log.Printf("❌ [LoginUser] Failed to map user: %v", err)
		return nil, status.Errorf(codes.Internal, "failed to map user: %v", err)
	}

	return user, nil
}

// User отдает одного пользователя по ID.
func (r *queryResolver) User(ctx context.Context, id string) (*ent.User, error) {
	userId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.User.Get(ctx, userId)
}

// UserBySlug отдает одного пользователя по slug.
func (r *queryResolver) UserBySlug(ctx context.Context, slug string) (*ent.User, error) {
	return r.Client.User.
		Query().
		Where(user.SlugEQ(slug)).
		WithAvatar().
		WithBanner().
		WithUserInfo().
		WithHostRoles().
		WithCommunitiesRoles().
		WithCommunitiesBans().
		WithCommunitiesMutes().
		WithPosts().
		Only(ctx)
}

// Users возвращает всех пользователей.
func (r *queryResolver) Users(ctx context.Context) ([]*ent.User, error) {
	return r.Client.User.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// ProfileTableInfoItem возвращает один итем профиля по ID итема.
func (r *queryResolver) ProfileTableInfoItem(ctx context.Context, id string) (*ent.ProfileTableInfoItem, error) {
	itemId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.ProfileTableInfoItem.Get(ctx, itemId)
}

// ProfileTableInfoItems отдает все итемы, которые есть у профиля.
func (r *queryResolver) ProfileTableInfoItems(ctx context.Context, id string, typeArg profiletableinfoitem.Type) ([]*ent.ProfileTableInfoItem, error) {
	profileID, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	q := r.Client.ProfileTableInfoItem.Query()
	switch typeArg {
	case profiletableinfoitem.TypeCommunity:
		q = q.Where(profiletableinfoitem.CommunityIDEQ(profileID))
	case profiletableinfoitem.TypeUser:
		q = q.Where(profiletableinfoitem.UserIDEQ(profileID))
	default:
		return nil, fmt.Errorf("unsupported ProfileTableInfoItemType %q", typeArg)
	}

	return q.Order(ent.Asc("id")).All(ctx)
}

// Post отдает один пост по ID.
func (r *queryResolver) Post(ctx context.Context, id string) (*ent.Post, error) {
	postId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Post.
		Query().
		Where(post.IDEQ(postId)).
		WithCommunity().
		WithAuthor().
		Only(ctx)
}

// PostBySlug отдает один пост по его slug.
func (r *queryResolver) PostBySlug(ctx context.Context, slug string) (*ent.Post, error) {
	return r.Client.Post.
		Query().
		Where(post.SlugEQ(slug)).
		WithHeroImage().
		WithCommunity().
		WithAuthor().
		Only(ctx)
}

// Posts возвращает посты в зависимости от их visibility.
func (r *queryResolver) Posts(ctx context.Context, visibility *post.Visibility, communityID *string, authorID *string) ([]*ent.Post, error) {
	q := r.Client.Post.Query()

	// 1) фильтр по visibility
	if visibility != nil {
		q = q.Where(post.VisibilityEQ(*visibility))
	}

	// 2) фильтр по сообществу, если передан
	if communityID != nil {
		cid, err := strconv.Atoi(*communityID)
		if err != nil {
			return nil, fmt.Errorf("invalid communityID %q: %w", *communityID, err)
		}
		q = q.Where(post.CommunityIDEQ(cid))
	}

	// 3) фильтр по автору, если передан
	if authorID != nil {
		aid, err := strconv.Atoi(*authorID)
		if err != nil {
			return nil, fmt.Errorf("invalid authorID %q: %w", *authorID, err)
		}
		q = q.Where(post.AuthorIDEQ(aid))
	}

	// 4) подгружаем связи и отдаем результат
	posts, err := q.
		WithCommunity().
		WithAuthor().
		All(ctx)
	if err != nil {
		return nil, err
	}
	return posts, nil
}

// BookmarkedPosts is the resolver for the bookmarkedPosts field.
func (r *queryResolver) BookmarkedPosts(ctx context.Context, visibility *post.Visibility) ([]*ent.Post, error) {
	// Получаем ID текущего пользователя
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized: %w", err)
	}

	// Получаем посты в закладках пользователя
	q := r.Client.Post.Query().
		Where(
			post.HasBookmarksWith(
				bookmark.UserIDEQ(userID),
			),
		)

	// Фильтр по visibility
	if visibility != nil {
		q = q.Where(post.VisibilityEQ(*visibility))
	}

	posts, err := q.
		Order(ent.Desc(post.FieldCreatedAt)).
		All(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to get bookmarked posts: %w", err)
	}

	return posts, nil
}

// FeedPosts is the resolver for the feedPosts field.
func (r *queryResolver) FeedPosts(ctx context.Context, visibility *post.Visibility) ([]*ent.Post, error) {
	// Получаем ID текущего пользователя
	userID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized: %w", err)
	}

	// Получаем посты от пользователей на которых подписан текущий пользователь
	// И посты из сообществ на которые подписан пользователь
	q := r.Client.Post.Query().
		Where(
			post.Or(
				// Посты от пользователей на которых подписан
				post.HasAuthorWith(
					user.HasFollowersWith(
						userfollow.FollowerIDEQ(userID),
					),
				),
				// Посты из сообществ на которые подписан
				post.HasCommunityWith(
					community.HasFollowersWith(
						communityfollow.UserIDEQ(userID),
					),
				),
			),
		)

	// Фильтр по visibility
	if visibility != nil {
		q = q.Where(post.VisibilityEQ(*visibility))
	}

	posts, err := q.
		Order(ent.Desc(post.FieldCreatedAt)).
		All(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to get feed posts: %w", err)
	}

	return posts, nil
}

// Comments возвращает все не удаленные комментарии.
func (r *queryResolver) Comments(ctx context.Context, hasDeleted *bool) ([]*ent.Comment, error) {
	return r.CommentUC.GetAllComments(ctx, hasDeleted)
}

// CommentsByPostID возвращает все комментарии одного поста по его slug.
func (r *queryResolver) CommentsByPostID(ctx context.Context, id string, hasDeleted *bool) ([]*ent.Comment, error) {
	pid, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}
	// Используем облегченную версию для снижения нагрузки на PostgreSQL
	return r.CommentUC.GetCommentsByPostIDLight(ctx, pid, hasDeleted)
}

// CommentsByPostIDPage возвращает комментарии одного поста постранично
func (r *queryResolver) CommentsByPostIDPage(ctx context.Context, id string, hasDeleted *bool, limit *int32, offset *int32) ([]*ent.Comment, error) {
	pid, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}

	var lim int32 = 40
	if limit != nil && *limit > 0 {
		lim = *limit
	}

	var off int32 = 0
	if offset != nil && *offset > 0 {
		off = *offset
	}

	return r.CommentUC.GetCommentsByPostIDLightPaginated(ctx, pid, hasDeleted, lim, off)
}

// CommentsByPostConnection реализует двунаправленную курсорную пагинацию
func (r *queryResolver) CommentsByPostConnection(ctx context.Context, postID string, first *int32, after *string, last *int32, before *string, hasDeleted *bool) (*models.CommentsConnection, error) {
	pid, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}
	var f *int
	var l *int
	if first != nil {
		fv := int(*first)
		f = &fv
	}
	if last != nil {
		lv := int(*last)
		l = &lv
	}
	return r.CommentUC.CommentsByPostConnection(ctx, pid, hasDeleted, f, after, l, before)
}

// CommentsWindow возвращает окно вокруг якоря
func (r *queryResolver) CommentsWindow(ctx context.Context, postID string, anchorID string, before *int32, after *int32, hasDeleted *bool) (*models.CommentsConnection, error) {
	pid, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}
	aid, err := strconv.Atoi(anchorID)
	if err != nil {
		return nil, fmt.Errorf("invalid anchor ID: %w", err)
	}
	b := 20
	if before != nil && *before > 0 {
		b = int(*before)
	}
	a := 20
	if after != nil && *after > 0 {
		a = int(*after)
	}
	return r.CommentUC.CommentsWindow(ctx, pid, aid, b, a, hasDeleted)
}

// CommentByID возвращает комментарий по ID
func (r *queryResolver) CommentByID(ctx context.Context, id string) (*ent.Comment, error) {
	cid, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid comment ID: %w", err)
	}
	return r.CommentUC.CommentByID(ctx, cid)
}

// CommentsFeed is the resolver for the commentsFeed field.
func (r *queryResolver) CommentsFeed(ctx context.Context, limit *int32) ([]*ent.Comment, error) {
	limitValue := int32(50)
	if limit != nil {
		limitValue = *limit
	}

	return r.CommentUC.GetCommentsFeed(ctx, limitValue)
}

// CommentsFeedConnection реализует курсорную выдачу общей ленты
func (r *queryResolver) CommentsFeedConnection(ctx context.Context, first *int32, after *string, last *int32, before *string, hasDeleted *bool) (*models.CommentsConnection, error) {
	var f *int
	var l *int
	if first != nil {
		fv := int(*first)
		f = &fv
	}
	if last != nil {
		lv := int(*last)
		l = &lv
	}
	return r.CommentUC.CommentsFeedConnection(ctx, hasDeleted, f, after, l, before)
}

// Role возвращает роль по ее ID.
func (r *queryResolver) Role(ctx context.Context, id string) (*ent.Role, error) {
	roleId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Role.Get(ctx, roleId)
}

// Roles возвращает все роли сообщества по ID сообщества.
func (r *queryResolver) Roles(ctx context.Context, id string) ([]*ent.Role, error) {
	communityId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	q := r.Client.Role.Query()
	q = q.Where(role.CommunityIDEQ(communityId))
	return q.Order(ent.Asc("id")).All(ctx)
}

// HostRole возвращает роль хоста по ее ID.
func (r *queryResolver) HostRole(ctx context.Context, id string) (*ent.HostRole, error) {
	hostRoleId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.HostRole.Get(ctx, hostRoleId)
}

// HostRoles возвращает список всех ролей платформы.
func (r *queryResolver) HostRoles(ctx context.Context) ([]*ent.HostRole, error) {
	return r.Client.HostRole.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostUserBan отдает одного забаненного пользователя по ID.
func (r *queryResolver) HostUserBan(ctx context.Context, id string) (*ent.HostUserBan, error) {
	hostUserBanId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.HostUserBan.Get(ctx, hostUserBanId)
}

// HostUsersBan возвращает список забаненных юзеров на платформе.
func (r *queryResolver) HostUsersBan(ctx context.Context) ([]*ent.HostUserBan, error) {
	return r.Client.HostUserBan.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostSidebarNavigationItems возвращает список всех итемов навигации платформы.
func (r *queryResolver) HostSidebarNavigationItems(ctx context.Context) ([]*ent.HostSidebarNavigationItem, error) {
	return r.Client.HostSidebarNavigationItem.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostSidebarNavigation всегда отдаёт HostSidebarNavigation с ID 1.
func (r *queryResolver) HostSidebarNavigation(ctx context.Context) (*ent.HostSidebarNavigation, error) {
	return r.Client.HostSidebarNavigation.Get(ctx, 1)
}

// HostSocialNavigation всегда отдаёт HostSocialNavigation с ID 1.
func (r *queryResolver) HostSocialNavigation(ctx context.Context) (*ent.HostSocialNavigation, error) {
	return r.Client.HostSocialNavigation.Get(ctx, 1)
}

// Host всегда отдаёт хост с ID 1.
func (r *queryResolver) Host(ctx context.Context) (*ent.Host, error) {
	return r.Client.Host.Get(ctx, 1)
}

// CommunityRoles is the resolver for the communityRoles field.
func (r *queryResolver) CommunityRoles(ctx context.Context, communityID string) ([]*ent.Role, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		fmt.Printf("❌ CommunityRoles: unauthenticated - %v\n", err)
		return nil, fmt.Errorf("unauthenticated")
	}

	fmt.Printf("🔍 CommunityRoles: userID=%d, communityID=%s\n", currentUserID, communityID)

	cid, err := strconv.Atoi(communityID)
	if err != nil {
		fmt.Printf("❌ CommunityRoles: invalid communityID - %v\n", err)
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем существование сообщества
	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		fmt.Printf("❌ CommunityRoles: community not found - %v\n", err)
		return nil, fmt.Errorf("community not found: %w", err)
	}

	fmt.Printf("✅ CommunityRoles: found community ID=%d, OwnerID=%d\n", cm.ID, cm.OwnerID)

	// Проверяем владельца/права
	if cm.OwnerID != currentUserID {
		fmt.Printf("🔍 CommunityRoles: user is not owner, checking permissions...\n")
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			fmt.Printf("❌ CommunityRoles: failed to get permissions - %v\n", err)
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil {
			fmt.Printf("❌ CommunityRoles: no permissions found for user\n")
			return nil, fmt.Errorf("forbidden: no permissions found")
		}
		if !perms.CommunityRolesManagement {
			fmt.Printf("❌ CommunityRoles: user lacks CommunityRolesManagement permission\n")
			return nil, fmt.Errorf("forbidden: only owner or role manager can view roles")
		}
		fmt.Printf("✅ CommunityRoles: user has CommunityRolesManagement permission\n")
	} else {
		fmt.Printf("✅ CommunityRoles: user is owner\n")
	}

	roles, err := r.CommunityRoleUC.GetCommunityRoles(ctx, cid)
	if err != nil {
		fmt.Printf("❌ CommunityRoles: failed to get roles - %v\n", err)
		return nil, err
	}

	fmt.Printf("✅ CommunityRoles: found %d roles\n", len(roles))
	return roles, nil
}

// CommunityRole is the resolver for the communityRole field.
func (r *queryResolver) CommunityRole(ctx context.Context, id string) (*ent.Role, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	roleID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid role ID: %w", err)
	}

	// Получаем роль для проверки сообщества
	role, err := r.Client.Role.Get(ctx, roleID)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, role.CommunityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{role.CommunityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[role.CommunityID]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can view role")
		}
	}

	return r.CommunityRoleUC.GetCommunityRole(ctx, roleID)
}

// HostCommunityBans is the resolver for the hostCommunityBans field.
func (r *queryResolver) HostCommunityBans(ctx context.Context) ([]*models.HostCommunityBan, error) {
	// Проверяем права: только владелец платформы или пользователи с hostCommunityDeletePost
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return nil, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostCommunityDeletePost {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return nil, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	bans, err := r.BanUC.GetHostCommunityBans(ctx)
	if err != nil {
		return nil, err
	}

	// Маппинг ent -> models
	result := make([]*models.HostCommunityBan, len(bans))
	for i, ban := range bans {
		result[i] = &models.HostCommunityBan{
			ID:          strconv.Itoa(ban.ID),
			CommunityID: strconv.Itoa(ban.CommunityID),
			CreatedAt:   ban.CreatedAt,
			UpdatedAt:   ban.UpdatedAt,
		}
	}

	return result, nil
}

// HostCommunityBan is the resolver for the hostCommunityBan field.
func (r *queryResolver) HostCommunityBan(ctx context.Context, id string) (*models.HostCommunityBan, error) {
	// Проверяем права: только владелец платформы или пользователи с hostCommunityDeletePost
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	hostEntity, err := r.Client.Host.Get(ctx, 1)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца или роли
	if hostEntity.OwnerID == nil || *hostEntity.OwnerID != currentUserID {
		// Проверяем роли пользователя
		roles, err := r.Client.User.Query().
			Where(user.IDEQ(currentUserID)).
			QueryHostRoles().
			All(ctx)
		if err != nil {
			return nil, err
		}

		hasPermission := false
		for _, role := range roles {
			if role.HostCommunityDeletePost {
				hasPermission = true
				break
			}
		}
		if !hasPermission {
			return nil, fmt.Errorf("forbidden: insufficient permissions")
		}
	}

	banID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid banID: %w", err)
	}

	ban, err := r.Client.HostCommunityBan.Get(ctx, banID)
	if err != nil {
		return nil, err
	}

	// Маппинг ent -> models
	return &models.HostCommunityBan{
		ID:          strconv.Itoa(ban.ID),
		CommunityID: strconv.Itoa(ban.CommunityID),
		CreatedAt:   ban.CreatedAt,
		UpdatedAt:   ban.UpdatedAt,
	}, nil
}

// CommunityUserBans is the resolver for the communityUserBans field.
func (r *queryResolver) CommunityUserBans(ctx context.Context, communityID string) ([]*ent.CommunityUserBan, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserBan
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil || !perms.CommunityUserBan {
			return nil, fmt.Errorf("forbidden: only owner or users with ban permission can view bans")
		}
	}

	return r.BanUC.GetCommunityUserBans(ctx, cid)
}

// CommunityUserMutes is the resolver for the communityUserMutes field.
func (r *queryResolver) CommunityUserMutes(ctx context.Context, communityID string) ([]*ent.CommunityUserMute, error) {
	// Проверяем права: владелец сообщества или пользователи с communityUserMute
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil || !perms.CommunityUserMute {
			return nil, fmt.Errorf("forbidden: only owner or users with mute permission can view mutes")
		}
	}

	return r.BanUC.GetCommunityUserMutes(ctx, cid)
}

// UsersForRole is the resolver for the usersForRole field.
func (r *queryResolver) UsersForRole(ctx context.Context, roleID string, search *string) ([]*ent.User, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	rid, err := strconv.Atoi(roleID)
	if err != nil {
		return nil, fmt.Errorf("invalid roleID: %w", err)
	}

	// Получаем роль для проверки сообщества
	role, err := r.Client.Role.Get(ctx, rid)
	if err != nil {
		return nil, err
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, role.CommunityID)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{role.CommunityID})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[role.CommunityID]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can view users for role")
		}
	}

	// Получаем пользователей роли
	roleEntity, err := r.Client.Role.Get(ctx, rid)
	if err != nil {
		return nil, err
	}
	users, err := roleEntity.QueryUsers().All(ctx)
	if err != nil {
		return nil, err
	}

	// Фильтруем по поиску если есть
	if search != nil && *search != "" {
		filtered := make([]*ent.User, 0)
		for _, user := range users {
			if strings.Contains(strings.ToLower(user.Name), strings.ToLower(*search)) ||
				strings.Contains(strings.ToLower(user.Slug), strings.ToLower(*search)) {
				filtered = append(filtered, user)
			}
		}
		return filtered, nil
	}

	return users, nil
}

// CommunityUsers is the resolver for the communityUsers field.
func (r *queryResolver) CommunityUsers(ctx context.Context, communityID string) ([]*ent.User, error) {
	// Проверяем права: владелец сообщества или менеджер ролей
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем владельца/права
	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		return nil, err
	}
	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can view community users")
		}
	}

	// Получаем пользователей сообщества через роли
	users, err := r.Client.Role.Query().
		Where(role.CommunityIDEQ(cid)).
		QueryUsers().
		All(ctx)
	if err != nil {
		return nil, err
	}

	return users, nil
}

// CommunityFollowers возвращает подписчиков сообщества с фильтрацией
func (r *queryResolver) CommunityFollowers(ctx context.Context, communityID string, filter *models.CommunityFollowersFilter, limit *int32, offset *int32) ([]*ent.User, error) {
	// Проверяем авторизацию
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	// Проверяем права: владелец сообщества или менеджер ролей
	cm, err := r.Client.Community.Get(ctx, cid)
	if err != nil {
		return nil, fmt.Errorf("community not found: %w", err)
	}

	if cm.OwnerID != currentUserID {
		permsMap, err := r.UserUC.GetPermissionsByCommunities(ctx, currentUserID, []int{cid})
		if err != nil {
			return nil, fmt.Errorf("permissions: %w", err)
		}
		perms := permsMap[cid]
		if perms == nil || !perms.CommunityRolesManagement {
			return nil, fmt.Errorf("forbidden: only owner or role manager can view followers")
		}
	}

	// Устанавливаем значения по умолчанию
	filterValue := models.CommunityFollowersFilterAll
	if filter != nil {
		filterValue = *filter
	}

	limitValue := 50
	if limit != nil {
		limitValue = int(*limit)
	}

	offsetValue := 0
	if offset != nil {
		offsetValue = int(*offset)
	}

	// Базовый запрос подписчиков через community_follows
	query := r.Client.User.Query().
		Where(
			user.HasCommunitiesFollowWith(
				communityfollow.CommunityIDEQ(cid),
			),
		).
		Limit(limitValue).
		Offset(offsetValue).
		Order(ent.Asc("id"))

	// Применяем фильтры
	switch filterValue {
	case models.CommunityFollowersFilterBanned:
		// Только забаненные пользователи
		query = query.Where(
			user.HasCommunitiesBansWith(
				communityuserban.CommunityIDEQ(cid),
			),
		)

	case models.CommunityFollowersFilterMuted:
		// Только замученные пользователи
		query = query.Where(
			user.HasCommunitiesMutesWith(
				communityusermute.CommunityIDEQ(cid),
			),
		)

	case models.CommunityFollowersFilterActive:
		// Только активные пользователи (не забаненные и не замученные)
		query = query.Where(
			user.Not(
				user.HasCommunitiesBansWith(
					communityuserban.CommunityIDEQ(cid),
				),
			),
			user.Not(
				user.HasCommunitiesMutesWith(
					communityusermute.CommunityIDEQ(cid),
				),
			),
		)

	case models.CommunityFollowersFilterAll:
		// Все подписчики (без дополнительных фильтров)
		// Уже настроено выше
	}

	return query.All(ctx)
}

// CommentAdded подписка на новые комментарии.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *ent.Comment, error) {
	pid, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	subID, ch := subscribeCommentAdded(pid)

	// отписка при закрытии клиента
	go func() {
		<-ctx.Done()
		unsubscribeCommentAdded(pid, subID)
	}()

	return ch, nil
}

// CommentUpdated подписка на обновления комментариев.
func (r *subscriptionResolver) CommentUpdated(ctx context.Context, postID string) (<-chan *ent.Comment, error) {
	pid, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid postID: %w", err)
	}
	subID, ch := subscribeCommentUpdated(pid)

	// отписка при закрытии клиента
	go func() {
		<-ctx.Done()
		unsubscribeCommentUpdated(pid, subID)
	}()

	return ch, nil
}

// CommentAddedGlobal — глобальная подписка для общей ленты (только опубликованные посты)
func (r *subscriptionResolver) CommentAddedGlobal(ctx context.Context) (<-chan *ent.Comment, error) {
	subID, ch := subscribeCommentAddedGlobal()
	// отписка при закрытии клиента
	go func() {
		<-ctx.Done()
		unsubscribeCommentAddedGlobal(subID)
	}()
	return ch, nil
}

// CommentUpdatedGlobal — глобальная подписка на обновления комментариев для общей ленты
func (r *subscriptionResolver) CommentUpdatedGlobal(ctx context.Context) (<-chan *ent.Comment, error) {
	subID, ch := subscribeCommentUpdatedGlobal()
	// отписка при закрытии клиента
	go func() {
		<-ctx.Done()
		unsubscribeCommentUpdatedGlobal(subID)
	}()
	return ch, nil
}

// UserStatus возвращает статус пользователя.
func (r *userResolver) UserStatus(ctx context.Context, obj *ent.User) (*models.UserStatus, error) {
	// 1) Получаем currentUserID из контекста (анонимы получат пустой статус)
	currentUserID, err := auth.UserIDFromContext(ctx)
	if err != nil {
		// аноним — просто вернём нулевой объект
		return &models.UserStatus{
			FollowersCount: "0",
			FollowingCount: "0",
			PostsCount:     "0",
			IsHostBanned:   false,
			IsHostMuted:    false,
			IsFollowing:    false,
		}, nil
	}

	// 2) Вызываем usecase для юзера
	status, err := r.UserUC.GetUserStatus(ctx, currentUserID, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("UserStatus usecase: %w", err)
	}

	return status, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
