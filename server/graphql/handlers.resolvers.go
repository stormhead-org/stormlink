package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"stormlink/server/ent"
	"stormlink/server/ent/community"
	"stormlink/server/ent/communityuserban"
	"stormlink/server/ent/communityusermute"
	"stormlink/server/ent/post"
	"stormlink/server/ent/role"
	"stormlink/server/model"
	"stormlink/server/model/converter"
	"stormlink/server/pkg/auth"
	"stormlink/server/pkg/permissionloader"
	"strconv"
	"time"

	"github.com/gosimple/slug"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Мутация Host для настроек платформы.
func (r *mutationResolver) Host(ctx context.Context, input UpdateHostInput) (*ent.Host, error) {
	upd := r.Client.Host.UpdateOneID(1)
	// каждый Set* вызываем только если в input поле не nil
	if input.Title != nil {
		upd = upd.SetTitle(*input.Title)
	}
	if input.Slogan != nil {
		upd = upd.SetSlogan(*input.Slogan)
	}
	if input.Contacts != nil {
		upd = upd.SetContacts(*input.Contacts)
	}
	if input.Description != nil {
		upd = upd.SetDescription(*input.Description)
	}
	if input.FirstSettings != nil {
		upd = upd.SetFirstSettings(*input.FirstSettings)
	}
	return upd.Save(ctx)
}

// Мутация Post для редактирования поста
func (r *mutationResolver) Post(ctx context.Context, input UpdatePostInput) (*ent.Post, error) {
	id, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID %q: %w", input.ID, err)
	}
	upd := r.Client.Post.
		UpdateOneID(id)
	if input.Title != nil {
		upd = upd.SetTitle(*input.Title)
	}
	if input.Slug != nil {
		upd = upd.SetSlug(*input.Slug)
	}
	if input.Content != nil {
		var content map[string]interface{}
		if err := json.Unmarshal([]byte(*input.Content), &content); err != nil {
			return nil, fmt.Errorf("invalid JSON for content: %w", err)
		}
		upd = upd.SetContent(content)
	}
	if input.HeroImageID != nil {
		heroID, err := strconv.Atoi(*input.HeroImageID)
		if err != nil {
			return nil, fmt.Errorf("invalid heroImageID %q: %w", *input.HeroImageID, err)
		}
		upd = upd.SetHeroImageID(heroID)
	}
	if input.Views != nil {
		upd = upd.SetViews(int(*input.Views))
	}
	if input.Status != nil {
		upd = upd.SetStatus(*input.Status)
	}
	if input.PublishedAt != nil {
		upd = upd.SetPublishedAt(*input.PublishedAt)
	}
	return upd.Save(ctx)
}

// CreatePost создает новый пост и генерирует slug.
func (r *mutationResolver) CreatePost(ctx context.Context, input CreatePostInput) (*ent.Post, error) {
	baseSlug := slug.Make(input.Title)
	suffix := rand.Intn(90_000_000) + 10_000_000
	finalSlug := fmt.Sprintf("%s-%d", baseSlug, suffix)

	var contentData map[string]interface{}
	if err := json.Unmarshal([]byte(input.Content), &contentData); err != nil {
		return nil, fmt.Errorf("invalid JSON in content: %w", err)
	}

	communityID, err := strconv.Atoi(input.CommunityID)
	if err != nil {
		return nil, fmt.Errorf("invalid communityID: %w", err)
	}

	authorID, err := strconv.Atoi(input.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("invalid authorID: %w", err)
	}
	builder := r.Client.Post.
		Create().
		SetTitle(input.Title).
		SetSlug(finalSlug).
		SetContent(contentData).
		SetAuthorID(authorID).
		SetCommunityID(communityID)

	if input.HeroImageID != nil {
		if mediaID, err := strconv.Atoi(*input.HeroImageID); err == nil {
			builder = builder.SetHeroImageID(mediaID)
		}
	}

	if input.Status != nil {
		builder = builder.SetStatus(post.Status(*input.Status))
	}

	if input.PublishedAt != nil {
		builder = builder.SetPublishedAt(time.Time(*input.PublishedAt))
	}

	newPost, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create post: %w", err)
	}
	return newPost, nil
}

// CreateCommunity создает новое сообщество.
func (r *mutationResolver) CreateCommunity(ctx context.Context, input CreateCommunityInput) (*ent.Community, error) {
	exists, err := r.Client.Community.
		Query().
		Where(community.SlugEQ(input.Slug)).
		Exist(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing slug: %w", err)
	}
	if exists {
		return nil, gqlerror.Errorf("Community with slug %q already exists", input.Slug)
	}

	newComm, err := r.Client.Community.
		Create().
		SetTitle(input.Title).
		SetSlug(input.Slug).
		SetNillableDescription(input.Description).
		SetOwnerID(func() int {
			id, _ := strconv.Atoi(input.OwnerID)
			return id
		}()).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create community: %w", err)
	}
	return newComm, nil
}

// ViewerPermissions отдает каждому юзеру права в зависимости от того, какие у него есть роли в сообществах.
func (r *postResolver) ViewerPermissions(ctx context.Context, obj *ent.Post) (*model.CommunityPermissions, error) {
	loader, ok := ctx.Value(permissionloader.ContextKey).(*permissionloader.PermLoader)
	if !ok {
		return converter.ConvertPermissionsToCommunityPermissions(&model.CommunityPermissions{}), nil
	}
	perm := loader.ForCommunity(obj.Edges.Community.ID)
	return converter.ConvertPermissionsToCommunityPermissions(perm), nil
}

// Media возвращает медиа по ID.
func (r *queryResolver) Media(ctx context.Context, id string) (*ent.Media, error) {
	mediaId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Media.Get(ctx, mediaId)
}

// Community отдает одно сообщество по ID.
func (r *queryResolver) Community(ctx context.Context, id string) (*ent.Community, error) {
	communityId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Community.Get(ctx, communityId)
}

// Communities возвращает все или только не забаненные сообщества.
func (r *queryResolver) Communities(ctx context.Context, onlyNotBanned *bool) ([]*ent.Community, error) {
	q := r.Client.Community.Query()
	if onlyNotBanned == nil || *onlyNotBanned {
		q = q.Where(community.CommunityHasBanned(false))
	}
	return q.Order(ent.Asc("id")).All(ctx)
}

// CommunityUserBan отдает запись о бане юзера по userID и communityID.
func (r *queryResolver) CommunityUserBan(ctx context.Context, communityID string, userID string) (*ent.CommunityUserBan, error) {
	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, err
	}
	uid, err := strconv.Atoi(userID)
	if err != nil {
		return nil, err
	}
	ban, err := r.Client.CommunityUserBan.
		Query().
		Where(
			communityuserban.CommunityIDEQ(cid),
			communityuserban.UserIDEQ(uid),
		).
		Only(ctx)
	if ent.IsNotFound(err) {
		return nil, nil
	}
	return ban, err
}

// CommunityUserMute отдает запись о муте юзера по userID и communityID.
func (r *queryResolver) CommunityUserMute(ctx context.Context, communityID string, userID string) (*ent.CommunityUserMute, error) {
	cid, err := strconv.Atoi(communityID)
	if err != nil {
		return nil, err
	}
	uid, err := strconv.Atoi(userID)
	if err != nil {
		return nil, err
	}
	mute, err := r.Client.CommunityUserMute.
		Query().
		Where(
			communityusermute.CommunityIDEQ(cid),
			communityusermute.UserIDEQ(uid),
		).
		Only(ctx)
	if ent.IsNotFound(err) {
		return nil, nil
	}
	return mute, err
}

// User отдает одного пользователя по ID.
func (r *queryResolver) User(ctx context.Context, id string) (*ent.User, error) {
	userId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.User.Get(ctx, userId)
}

// Users возвращает всех пользователей.
func (r *queryResolver) Users(ctx context.Context) ([]*ent.User, error) {
	return r.Client.User.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// Post отдает один пост по ID.
func (r *queryResolver) Post(ctx context.Context, id string) (*ent.Post, error) {
	postId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Post.Get(ctx, postId)
}

// Posts возвращает посты в зависимости от их статуса.
func (r *queryResolver) Posts(ctx context.Context, status *post.Status) ([]*ent.Post, error) {
	posts, err := r.Client.Post.
		Query().
		Where(post.StatusEQ(post.Status(string(*status)))).
		WithCommunity().
		WithAuthor().
		All(ctx)
	if err != nil {
		return nil, err
	}
	// Получаем текущего пользователя из контекста
	userID, _ := auth.UserIDFromContext(ctx)

	// Собираем уникальные communityIDs
	set := map[int]struct{}{}
	for _, p := range posts {
		set[p.Edges.Community.ID] = struct{}{}
	}
	communityIDs := make([]int, 0, len(set))
	for cid := range set {
		communityIDs = append(communityIDs, cid)
	}
	// Загружаем все права
	loader := permissionloader.NewPermLoader(r.UC)
	if err := loader.LoadAll(ctx, userID, communityIDs); err != nil {
		return nil, err
	}
	// Кладём loader в контекст, чтобы его видел postResolver
	ctx = context.WithValue(ctx, permissionloader.ContextKey, loader)

	return posts, nil
}

// Role возвращает роль по ее ID.
func (r *queryResolver) Role(ctx context.Context, id string) (*ent.Role, error) {
	roleId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.Role.Get(ctx, roleId)
}

// Roles возвращает все роли сообщества по ID сообщества.
func (r *queryResolver) Roles(ctx context.Context, id string) ([]*ent.Role, error) {
	communityId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	q := r.Client.Role.Query()
	q = q.Where(role.CommunityIDEQ(communityId))
	return q.Order(ent.Asc("id")).All(ctx)
}

// HostRole возвращает роль хоста по ее ID.
func (r *queryResolver) HostRole(ctx context.Context, id string) (*ent.HostRole, error) {
	hostRoleId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.HostRole.Get(ctx, hostRoleId)
}

// HostRoles возвращает список всех ролей платформы.
func (r *queryResolver) HostRoles(ctx context.Context) ([]*ent.HostRole, error) {
	return r.Client.HostRole.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostUserBan отдает одного забаненного пользователя по ID.
func (r *queryResolver) HostUserBan(ctx context.Context, id string) (*ent.HostUserBan, error) {
	hostUserBanId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Client.HostUserBan.Get(ctx, hostUserBanId)
}

// HostUsersBan возвращает список забаненных юзеров на платформе.
func (r *queryResolver) HostUsersBan(ctx context.Context) ([]*ent.HostUserBan, error) {
	return r.Client.HostUserBan.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostSidebarNavigationItems возвращает список всех итемов навигации платформы.
func (r *queryResolver) HostSidebarNavigationItems(ctx context.Context) ([]*ent.HostSidebarNavigationItem, error) {
	return r.Client.HostSidebarNavigationItem.
		Query().
		Order(ent.Asc("id")).
		All(ctx)
}

// HostSidebarNavigation всегда отдаёт HostSidebarNavigation с ID 1.
func (r *queryResolver) HostSidebarNavigation(ctx context.Context) (*ent.HostSidebarNavigation, error) {
	return r.Client.HostSidebarNavigation.Get(ctx, 1)
}

// HostSocialNavigation всегда отдаёт HostSocialNavigation с ID 1.
func (r *queryResolver) HostSocialNavigation(ctx context.Context) (*ent.HostSocialNavigation, error) {
	return r.Client.HostSocialNavigation.Get(ctx, 1)
}

// Host всегда отдаёт хост с ID 1.
func (r *queryResolver) Host(ctx context.Context) (*ent.Host, error) {
	return r.Client.Host.Get(ctx, 1)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
